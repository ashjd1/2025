CKA


kubectl get all


master node and worked node

master node has control plan component by which it can manage multiple worked nodes and its containers

kubelet is present all the nodes and it alswas liset to master node and manage the node.
also master node fetches the data from kubelet to monitor nodes and container .

recent version from 1.24 version of k8s docker is not supported.
insted it support containerD, very similar to docker
so insted of "docekr ps -a" you will need to use "nerdctl ps -a" replace "docker" with "nerdctl".

ETCD (etcd cluster): -

	is a distributed reliable key value store, it stores data in key and value format.
	when you run any "kubectl get" command that time data get read from ETCD and then present to you.
	
kube-apiserver: -
	there are multiple component in k8s so connecting to all those component to each other and talking to eachother with right information 
	is done my kube-apiserver.
	
pods
	smallest block if k8s.
	in single pod we can have multiple container but not same kind of container, we can have multiple containers of differnt kinds.
	like you can't run two python container in single pod, but you can run python and nginx cotainers in single pod.


	you can create pods with commandline without yaml file. and you can create yaml file as well with command file
	follow the below commands
	
	$ kubectl run nginx-2 --image=nginx --dry-run=client -o yaml
	apiVersion: v1
	kind: Pod
	metadata:
	  creationTimestamp: null
	  labels:
		run: nginx-2
	  name: nginx-2
	spec:
	  containers:
	  - image: nginx
		name: nginx-2
		resources: {}
	  dnsPolicy: ClusterFirst
	  restartPolicy: Always
	status: {}
	
	$ kubectl run nginx-2 --image=nginx --dry-run=client -o yaml > pod.yaml
	
	$ ls
	pod.yaml

	$ kubectl create -f pod.yaml
	pod/nginx-2 created
	
	$ kubectl get pods
	NAME      READY   STATUS    RESTARTS   AGE
	nginx-2   1/1     Running   0          6s
	
	$ cat pod.yaml
	apiVersion: v1
	kind: Pod
	metadata:
	  creationTimestamp: null
	  labels:
		run: nginx-2
	  name: nginx-2
	spec:
	  containers:
	  - image: nginx
		name: nginx-2
		resources: {}
	  dnsPolicy: ClusterFirst
	  restartPolicy: Always
	status: {}
	
	$ kubectl run nginx --image=nginx
	pod/nginx created
	
	$ kubectl get pod
	NAME      READY   STATUS    RESTARTS   AGE
	nginx     1/1     Running   0          7s
	nginx-2   1/1     Running   0          3m33s



Replicaset: -
	
	replication controler is older technology and got replaced with replicaset.
	in replicationcontroller selector is not mandattery but in seplicaset it is mandatary.
	replicaset can manage pods which are created by the replicaset itself and also the pods matched with spec:selector:matchLabels, no matter when you create the pod.
	

	KEEP IN MIND:- in ReplicaSet you have to match the labes what every you are giving in spec:template:labels to spec:selector:matchLabels, otherwise you will get error.

	replicationcontroller: -
		$ kubectl get replicationcontroller
		NAME      DESIRED   CURRENT   READY   AGE
		replica   3         3         3       35m
		
		$ kubectl get pods
		NAME            READY   STATUS    RESTARTS   AGE
		replica-mr4hb   1/1     Running   0          35m
		replica-vclwt   1/1     Running   0          35m
		replica-xmfdm   1/1     Running   0          35m
		
		$ cat replicationController.yaml
		apiVersion: v1
		kind: ReplicationController
		metadata:
		  name: replica
		  labels:
			app: myapp-replica
		spec:
		  template:
			metadata:
			  name: replica-pod
			  labels:
				app: myapp-pod
			spec:
			  containers:
				- name: nginx-name
				  image: nginx
		  replicas: 3
		  
		  
		  
	ReplicaSet: -
		$ kubectl get rs
		NAME      DESIRED   CURRENT   READY   AGE
		replica   3         3         3       46s
		$ kubectl get pods
		NAME            READY   STATUS    RESTARTS   AGE
		replica-brv6z   1/1     Running   0          51s
		replica-bvks8   1/1     Running   0          51s
		replica-p8h2d   1/1     Running   0          51s
		$ cat replicaset.yaml
		apiVersion: apps/v1
		kind: ReplicaSet
		metadata:
		  name: replica
		  labels:
			app: myapp-replica
		spec:
		  template:
			metadata:
			  name: replica-pod
			  labels:
				app: myapp-pod
			spec:
			  containers:
				- name: nginx-name
				  image: nginx
		  replicas: 3
		  selector:
			matchLabels:
			  app: myapp-pod


	how to scale-up and scale-down the replicas 
		1. change the number in file and run "kubectl replace -f <file-name>" 
		2. there is command to scale the pods, "kubectl scale --replicas=10 -f <file-name>"
			will not change any file, but still you will have the changes
			
			
Deployment: -

	deploment is exactly same as replicalset, just one feature.
	you can role and role back your update to pods one after another, even you can pause the update as well.
	
	you can create deployment from command line, commands as below: -
	
	$ kubectl create deployment --image=nginx nginx
	deployment.apps/nginx created

	$ kubectl get deployment
	NAME    READY   UP-TO-DATE   AVAILABLE   AGE
	nginx   1/1     1            1           10s

	$ kubectl create deployment --image=nginx nginx-2 --dry-run=client -o yaml
	apiVersion: apps/v1
	kind: Deployment
	metadata:
	  creationTimestamp: null
	  labels:
		app: nginx
	  name: nginx
	spec:
	  replicas: 1
	  selector:
		matchLabels:
		  app: nginx
	  strategy: {}
	  template:
		metadata:
		  creationTimestamp: null
		  labels:
			app: nginx
		spec:
		  containers:
		  - image: nginx
			name: nginx
			resources: {}
	status: {}

	$ kubectl create deployment --image=nginx nginx-2 --dry-run=client -o yaml > deployment.yaml

	$ ls
	deployment.yaml

	$ kubectl get deployment
	NAME      READY   UP-TO-DATE   AVAILABLE   AGE
	nginx     1/1     1            1           2m22s
	nginx-2   1/1     1            1           13s

	$ kubectl get pods
	NAME                       READY   STATUS    RESTARTS   AGE
	nginx-2-8487d69879-746d2   1/1     Running   0          4m48s
	nginx-66686b6766-4qp6b     1/1     Running   0          6m57s


	$ kubectl create deployment --image=nginx nginx-with-4-replicas --replicas=4 --dry-run=client -o yaml
	apiVersion: apps/v1
	kind: Deployment
	metadata:
	  creationTimestamp: null
	  labels:
		app: nginx-with-4-replicas
	  name: nginx-with-4-replicas
	spec:
	  replicas: 4
	  selector:
		matchLabels:
		  app: nginx-with-4-replicas
	  strategy: {}
	  template:
		metadata:
		  creationTimestamp: null
		  labels:
			app: nginx-with-4-replicas
		spec:
		  containers:
		  - image: nginx
			name: nginx
			resources: {}
	status: {}

	$ kubectl create deployment --image=nginx nginx-with-4-replicas --replicas=4 --dry-run=client -o yaml  > nginx-deployment.yaml

	$ ls
	nginx-deployment.yaml

	$ kubectl create -f nginx-deployment.yaml
	deployment.apps/nginx-with-4-replicas created

	$ kubectl get deployment
	NAME                    READY   UP-TO-DATE   AVAILABLE   AGE
	nginx-with-4-replicas   3/4     4            3           9s

	$ kubectl get pods
	NAME                                     READY   STATUS    RESTARTS   AGE
	nginx-with-4-replicas-86d9bcd478-ftn5x   1/1     Running   0          17s
	nginx-with-4-replicas-86d9bcd478-mwnts   1/1     Running   0          17s
	nginx-with-4-replicas-86d9bcd478-q2x8d   1/1     Running   0          17s
	nginx-with-4-replicas-86d9bcd478-qfjqt   1/1     Running   0          17s

	$ cat nginx-deployment.yaml
	apiVersion: apps/v1
	kind: Deployment
	metadata:
	  creationTimestamp: null
	  labels:
		app: nginx-with-4-replicas
	  name: nginx-with-4-replicas
	spec:
	  replicas: 4
	  selector:
		matchLabels:
		  app: nginx-with-4-replicas
	  strategy: {}
	  template:
		metadata:
		  creationTimestamp: null
		  labels:
			app: nginx-with-4-replicas
		spec:
		  containers:
		  - image: nginx
			name: nginx
			resources: {}
	status: {}